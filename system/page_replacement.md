# 페이지 교체 알고리즘 (Page Replacement)

유한한 자원을 최고의 효율을 얻기 위해서 여러 알고리즘이 존재한다.

컴퓨터는 주기억 장치인 램과 보조 기억장치인 HDD, SSD 등의 대용량 기억장치를 가진다. 램은 속도가 빠르기 때문에 보조기억장치로부터 데이터를 램에 저장해놓고 램에 있는 데이터를 가지고 빠르게 연산한다. 이 과정에서 램을 같은 크기의 블록으로 나누어 운용하는데 이 블록을 **페이지**라고 한다.

CPU 가 계산 과정에서 데이터가 페이지에 있다면 이를 `cache-hit` 라고 부르며 데이터가 페이지에 없다면 보조기억장치로부터 데이터를 페이지로 옮겨온 후 계산을 하는데 이는 `cache-miss` 라고 부른다.

빠른 연산을 위해선 어떤 데이터를 램 장치에 오래 저장해 놓아야 하는지가 중요한 문제가 된다. 램의 물리적 자원이 같더라도 어떤 방식의 알고리즘을 사용하느냐에 따라 체감될 정도로 성능차이가 난다.

## FIFO (First In First Out)

> 가장 먼저 들어와 가장 오래 있었던 페이지를 교체하는 방법

향후 참조 가능성을 고려하지 않고 물리적 메모리에 들어온 순서대로 대상을 선정한다.

### 빌레디의 모순

페이지 프레임 수가 많으며 페이지 부재수가 줄어드는 것이 일반적이지만, 페이지 프레임 수를 증가시켰음에도 페이지 부재가 더 많이 일어나는 현상을 의미한다.

## LRU (Least Recently Used)

> 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 방법

시간 지역성의 성질을 가진 알고리즘으로 각 페이지는 계수기나 스택과 같은 자료구조를 가지며 사용될 때마다 0 으로 초기화 시키고 시간이 증가하면 오래된 페이지를 교체

## LFU (Least Frequently Used)

> 페이지의 참조 횟수로 교체할 페이지를 결정하는 방법

과거 참조 횟수가 가장 적은 페이지를 제거하고 그 자리에 새로 참조될 페이지를 옮긴다.

LFU 는 LRU 에 비해 오랜시간동안의 참조기록을 반영할 수 있다는 장점이 있다. LRU 는 직전의 참조 시점만 반영하지만 LFU 는 참조횟수를 통해서 장기적인 참조 규모를 가지기 때문이다.

## NRU (Not Recently Used)

> 최근에 사용하지 않은 페이지를 교체하는 방법

LRU 알고리즘은 가장 오래전 참조된 페이지를 교체하는 것에 비해, NRU 알고리즘은 오랫동안 사용하지 않은 페이지 중에서 하나를 교체한다.

최근 참조되지 않은 페이지를 선정하는 것은 같지만 NRU 는 교체되는 페이지의 참조 시점이 **가장 오래되었다는 것을 보장하지 않는다.**

최근 참조 여부를 확인하기 위해 각 페이지별 참조 비트(Reference Bit)와 변형 비트(Modified Bit) 2 개의 비트가 사용된다.

- 참조 비트: 페이지가 참조되지 않았을 때 0, 호출되었을 때 1로 지정
- 변형 비트: 페이지 내용이 변경되지 않았을 때 0, 변경되었을 때 1로 지정

교체에 사용하는 자원이 하드웨어적 자원으로 동작하기 때문에 LRU 에 비해 교체 페이지 선정이 빠르다는 장점을 가지고 있다.

## 학습내용 참고 출처

- [페이지 교체 알고리즘 - LRU](https://gomguard.tistory.com/115)
- [가상메모리-02-페이지 교체 알고리즘](https://eunhyejung.github.io/os/2018/07/24/operatingsystem-study15.html)
