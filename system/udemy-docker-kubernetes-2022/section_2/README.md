# 섹션 2

> 이미지란 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지이다.

이미지는 읽기 전용 파일이다. 컨테이너는 이미지로 실행된 구체적인 인스턴스로 따라서 이미지가 실행된 것이다. `docker build .` 를 통해 이미지를 만들 수 있다.

우리는 가장 쉽게 도커 허브를 통해서 이미지를 구할 수 있다.

```text
// docker pull node
docker run node
```

`docker run -it node` 로 `-it` 명령어를 포함시 실행한 컨테이너로 접속하면서 실행된다.

`docker ps -a` 를 실행 중인, 실행 되었던 컨테이너를 확인할 수 있다.

## Dockerfile

```Dockerfile
// 특정 이미지를 가져온다.
FROM node

// 컨테이너의 지정된 경로로 이동한다.
// 지정하지 않으면 루트 폴더로 지정된다.
WORKDIR /app

// 첫번째 . 컨테이너 외부, 이미지의 외부 경로
// 이 경우 같은 경로의 디렉토리의 파일을 전부 복사한다.
// 두번째 /app 컨테이너 자체 내부 파일 시스템 경로
// 가급적 폴더를 지정하는 것이 좋다.
COPY . /app

RUN npm install

// 컨테이너를 외부에 드러낼 포트
EXPOSE 80

// 이미지를 기반으로 컨테이너가 시작할 때 실행됨.
CMD ["node", "server.js"]
```

명령어 한줄 한줄을 이미지 레이어라고 부르며 레이어 하나씩 캐싱된다. 이전 명령어와 다시 실행했을 때의 명령어의 결과가 같다면 캐시하여 실행된다.

코드가 변경되었을 때는 `COPY . /app` 의 명령 결과가 다르게 실행된다. 이 때 하위 이미지 레이어의 결과도 같이 실행된다. 따라서 `RUN npm install` 도 실행되는데, `npm install` 은 `package.json` 에 의존한 수행이기 때문에 실행될 필요가 없다.

따라서 좀 더 튜닝한 Dockerfile 은 다음과 같이 된다.

```Dockerfile
FROM node

WORKDIR /app

COPY package.json /app

RUN npm install

COPY . /app

EXPOSE 80

CMD ["node", "server.js"]
```

도커는 이름과 태그를 가져 특정 태그를 선언하면 해당된 이미지를 가져온다.

## 컨테이너/이미지 명령어

### `docker build`

> 특정 상태의 파일을 이미지로 빌드한다.

`-t` : 빌드시 이름과 태그명을 기입할 수 있다.

### `docker ps`

> 실행중인 컨테이너를 확인한다.

`-a` : 실행했던 컨테이너도 확인한다.

### `docker run`

> 이미지를 새 컨테이너로 실행한다.

- `-p ${노출 포트} : ${연결 포트}` : 네트워크 모드로 포트를 노출시킨다.
- `-i` : 인터렉티브 모드, 표준 입력이 열린 상태로 유지한다. 컨테이너에 무언가를 입력할 수 있다.
- `-t` : 터미널을 생성한다.
- `-it` : ⭐⭐⭐ 터미널을 생성하고 컨테이너에 입력 가능한 인터렉티브 모드로 접속한다.
- `--rm` : ⭐⭐⭐ 중지되면 자동으로 컨테이너를 자동으로 제거한다.

기본적으로 attached 모드로 실행된다. 이미지 아이디로도 실행 가능하고 빌드 이름:태그 등으로도 실행 가능하다.

### `docker start`

> 컨테이너 아이디 또는 이름으로 이전에 실행했었던 컨테이너를 실행한다.

기본적으로 detached (백그라운드 실행) 모드로 실행된다.

- `-a` : attached 모드로 실행한다.
- `-i` : 인터렉티브 모드

### `docker stop`

> 실행되고 있는 컨테이너를 중지한다.

### `docker attach`

> 실행 중인 컨테이너에 접근한다. start 상태로 되는 것과 동일

### `docker logs`

> 컨테이너에서 출력된 과거의 로그를 확인할 수 있다.

- `-f` : 연결된 상태로 계속 확인할 수 있다.

### `docker rm`

> 중지된 상태의 컨테이너를 삭제한다.

`${id1} ${id2}` 처럼 나열하여 삭제할 수 있다.

### `docker images`

> 가지고 있는 모든 이미지를 나타낸다.

### `docker rmi`

> 이미지를 삭제한다. 단, 삭제할 이미지로 사용되고 있는 컨테이너가 모두 중지되어 있어야 한다. 중지되어 있지 않다면 컨테이너를 중지해야 한다.

`${id1} ${id2}` 처럼 나열하여 삭제할 수 있다.

### `docker image`

> 이미지와 관련된 명령어를 수행한다.

- `prune` : 사용되지 않는 모든 이미지를 제거한다.
- `inspect` : 이미지에 대한 정보가 출력된다.

### `docker cp`

> 로컬에 있는 이미지가 아닌 파일을 특정 컨테이너로 복사해서 넣는다. 반대로 컨테이너에 있는 파일을 로컬로 이동 가능하다.

`docker cp dummy/. boring_vaughan:/test` : 로컬에 있는 dummy 디렉토리 하위 파일을 컨테이너 test 경로로 복사한다.

`docker cp boring_vaughan:/test dummy` :  컨테이너의 test 디렉토리를 로컬에 있는 dummy 디렉토리로 복사한다.

### `docker push`

> 도커 허브에 이미지를 공유한다.

도커는 이미지를 푸시할 때 의존하는 파일이 이미 도커 허브에 있다면 추가 정보만 푸시하여 이미지를 경량화 한다.

### `docker pull`

> 도커 허브에서 **최신 업데이트** 이미지를 가져온다.

`docker run` 은 로컬에 히스토리를 검색해 없으면 이미지를 자동으로 풀링하지만, 로컬에 있다면 최신 버전인지 확인하지 않는다. 따라서 항상 최신 버전을 가져와야 한다면 `docker pull` 을 사용하고 최신 버전을 명시적으로 가져온 후 `docker run` 으로 실행해야한다.

### `docker login`

> 도커 허브에 로그인한다.

### `docker logout`

> 도커 허브에 로그아웃한다.

## 이미지 공유

특정 빌드한 나만의 이미지를 공유할 수 있다. 공유 방법은 크게 2가지이다.

1. Dockerfile 를 공유한다. 이 경우 추가로 실행 가능한 파일을 포함하여 공유해야 한다.
2. 빌드가 완료되어있는 이미지를 공유한다. 추가 코드나 주변 폴더가 필요 없다.

도커 허브 이미지 공유 하는 방법은 공통 도커 허브에 공유하는 방법과 개인 레지스트리로 공유하는 방법이 있다.

내가 만든 퍼블릭 리포에 `docker push ${user_name/repository_name}` 를 입력하면 현재 Dockerfile 경로로 이미지가 푸시된다.
