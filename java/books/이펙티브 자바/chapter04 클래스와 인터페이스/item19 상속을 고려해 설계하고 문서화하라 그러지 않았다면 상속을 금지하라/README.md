# ✨ 아이템 19: 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

상속용 클래스는 재정의할 수 있는 메서드를 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

- 다른 메소드의 호출 여부
- 호출되는 메소드가 있다면 재정의 가능 여부
- 해당 메소드 호출 순서
- 해당 메소드 호출 결과

`@impleSpec` 은 그 메서드의 내부 동작 방식을 설명하는 자바독 도구 생성 어노테이션으로 (표준 스펙은 아직 아니지만 자바 개발팀이 사용하기에 동일한 효과를 유지하기 위해선 사용하는 것이 바람직하다.) 자바 8 에 도입되어 9 부터 본격적으로 사용되고 있다.

이처럼 내부 메커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다. 클래스의 내부 동작 과정에서 중간에 끼어들 수 있는 훅을 선별하여 protected 메서드로 공개해야할 수 도 있다. 드물게 protected 필드인 경우도 있으며 현명하게 노출하는 방법은 **하위 클래스를 직접 만들어 사용하는 방법이 유일하다.**

사용하다보면 전혀 쓰이지 않는 protected 는 사실 private 할 가능성이 크다. 그러니 상속용으로 설계한 클래스는 배포 전 반드시 하위 클래스를 만들어 검증하여야 한다.

## 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해선 안된다

상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 생성자보다 먼저 호출된다. 이때 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.

더해 clone 과 readObject 모두 직접적으로 간접적으로든 재정의 가능 메서드에서 호출해서는 안된다.

- readObject: 하위 클래스의 상태가 미처 역직렬화되기 전에 재정의한 메서드부터 호출한다.
- clone: 하위 클래스의 clone 메서드가 복제본 상태를 올바르게 수정하기 전에 재정의한 메서드가 호출된다.

마지막으로 Serializable 을 구현한 상속용 클래스가 readResolve 나 writeReplace 메서드를 가지면 private 가 아닌 protected 로 선언해야 한다. private 로 선언하면 하위 클래스에서 무시되기 때문이다.

이처럼 상속은 엄청난 노력이 필요하기에 용도에 따라 상속을 금지하는 것이 나은 상황이 많이 있다.

상속을 막는 방법은 크게 2가지로 final 클래스로 선언하거나, 모든 생성자를 package-private 또는 private 생성자로 만든 뒤 public 정적 팩터리로 만드는 방법이 있다.
