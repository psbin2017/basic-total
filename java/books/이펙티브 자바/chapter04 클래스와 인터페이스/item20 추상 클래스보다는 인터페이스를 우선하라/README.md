# ✨ 아이템 20: 추상 클래스보다는 인터페이스를 우선하라

- 추상 클래스 : 구현체는 반드시 하위 클래스로 종속된다.
- 인터페이스 : 어떤 클래스를 상속해도 같은 타입으로 취급된다.

기존 클래스 위에 추상 클래스를 끼워 넣는다는 것은 일반적으로 어렵지만, 인터페이스는 구현하기 쉽다. 더하여 추상 클래스를 상속시 모든 자손이 이를 상속하게 되는데 필요치 않은 모든 상황에서도 강제된다는 의미이다.

## 믹스인

인터페이스는 *주된 타입* 외에도 특정 선택적 행위를 혼합하여 제공한다는 의미인 **믹스인(mixin)** 정의에 안성맞춤이다. 추상 클래스가 불가능한 이유는 클래스는 단일 상속만 지원하기 때문이다.

인터페이스는 현실에서 계층을 엄격히 구분하기 어려운 개념과 같은 내용을 해결 가능한 계층구조가 없는 타입 프레임워크를 만들 수 있다. [SingerSongWriter](https://github.com/psbin2017/garbage-collection/blob/master/gc/src/test/java/com/collection/gc/sample/interfaces/SingerSongWriter.java)

이 정도의 유연성이 항상 필요한 것은 아니지만 이렇게 만든 인터페이스가 결정적 상황에 도움을 줄 수 있다. 동일한 구조를 클래스로 만들려면 조합 가능한 케이스 전부를 각각 클래스로 정의한 고도비만 계층구조가 만들어진다. 지원해야하는 조합의 개수는 2^n 개나 된다.

## 디폴트 메소드

디폴트 메소드로 구현하여 프로그래머의 일감을 덜어줄 수 있다. `@impleSpec` 으로 문서화해야하며 `Object` 메소드를 디폴트 메소드로 제공해서는 안된다. 인스턴스 필드를 가질 수 없고 public 이 아닌 정적 멤버도 가질 수 없다. (단, private 정적 메서드는 예외)

## 추상 골격 구현

인터페이스와 추상 골격 구현 클래스를 제공하여 인터페이스와 추상클래스의 장점을 모두 가지는 방법도 있다. 인터페이스는 타입을 정의하고, 골격 구현 클래스로 나머지 메소드를 구현한다. 이렇게 하면 골격 구현 클래스를 확장하는 것으로 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다. 이는 시뮬레이트한 다중 상속(simulated multiple inheritance)이라 한다. [FishBreadMachine](https://github.com/psbin2017/garbage-collection/blob/master/gc/src/test/java/com/collection/gc/sample/interfaces/FishBreadMachine.java)

## 단순 구현

골격 구현의 변종으로 AbstractMap.SimpleEntity 가 좋은 예이다. 인터페이스를 구현하며 추상 클래스를 작성하지 않았다. 쉽게 말해 인터페이스의 단순 구현이다.
