# ✨ 아이템 18: 상속보다는 컴포지션을 사용하라

상속은 잘못 사용하면 오류를 내기 쉬운 소프트웨어가 된다. 프로그래머가 통제하는 패키지 안에서 확장할 목적과 문서화가 잘된 클래스는 안전하지만 이 경계를 넘어선 구체 클래스는 위험하다.

> 여기서 상속은 구현 상속에 대한 상속 내용이다.

메소드 호출과 달리 상속은 캡슐화가 깨진다. 달리 말하면 상위 클래스의 구현에 따라 하위 클래스의 내부 구현이 달라질 수 있으며, 이 여파로 코드 한줄 변경 없는 하위 클래스가 오동작을 일으킬 수 있다.

기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 구성요소를 쓰인다는 뜻의 컴포지션을 사용하여 문제를 회피하는 묘안이 있다. 기존 클래스의 대응하는 메소드를 호출하여 그 결과를 반환하는 forwarding 방식을 사용하여 (이 방식을 forwarding method 라고 한다.) 새로운 클래스는 기존 클래스의 내부 구현 방식에 벗어나지 못하면서 새로운 메소드가 추가되어도 영향받지 않는다.

컴포지션과 전달의 조합은 넓은 의미로 위임(delegation) 이라고 부른다. 단, 정확하게 따지자면 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위임에 해당한다.

전달 메서드를 작성하는게 지루하겠지만, 재사용할 수 있는 전달 클래스를 인터페이스당 하나씩만 만들어두면 원하는 기능을 덧씌우는 전달 클래스들을 손쉽게 구현할 수 있다. 예로는 구아바 라이브러리는 모든 컬렉션 인터페이스용 전달 메서드를 전부 구현하였다.

상속 은 반드시 *진짜* 하위 타입인 상황에서만 상속해야 한다. 클래스 A 를 상속하는 클래스 B 를 작성하려 한다면 B 가 정말 A 인가를 자문해봐야하며 확실할 수 없다면 B 는 A 를 상속해선 안된다. 이 경우 A 를 private 인스턴스로 두고 A 와는 다른 API 를 제공해야 하는 상황이 대다수다. 즉, **A 가 B 의 필수 구성요소가 아닌 구현하는 방법 중 하나가 될 뿐인 것이다.**

## 컴포지션 대신 상속을 사용하기 위한 결정 방법

1. 확장하려는 클래스의 API 에 결함이 없는가?
2. 결함이 있다면 해당 API 가 전파되어도 괜찮은가?

컴포지션은 이 결함을 숨기는 새로운 API 를 설계가 가능하지만 상속은 결함 API 를 승계한다.
