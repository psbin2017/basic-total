# ✨ 아이템 1: 생성자 대신 정적 팩토리 메소드를 고려하라

정적 팩토리 메소드의 장점

1. 이름(메소드명)을 가진다.
2. 호출 될 때마다 인스턴스를 새로 생성하지 않아도 된다.
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
5. 정적 팩토리 메소드를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않아도 된다.

정적 팩토리 메소드의 단점

1. 상속을 하려면 `public` 또는 `protected` 생성자를 필요로 하여 정적 팩토리 메소드만 제공시 하위 클래스를 만들수 없다.
2. 정적 팩토리 메소드는 프로그래머가 찾기 어렵다.

## 이름(메소드명)을 가짐

```java
/**
 * 30분 사용 가능한 코인 세탁기 객체
 * 메소드 명으로 코인 세탁기의 특성을 알 수 있다.
 */
public CoinWasher probableThiryMinutes(...) { }
```

생성자 오버로딩을 통해서 추가하는 식으로 이 제한을 회피할 수 있지만, 좋지 못한 발상이다.

## 호출 될 때마다 인스턴스를 새로 생성하지 않아도 됨

불변 클래스 인스턴스를 만들어 제공한다. 미리 캐싱된 인스턴스를 사용하여 객체 생성 비용이 큰 객체가 자주 요청되는 상황이라면 성능을 향상시킬 수 있다. 해당 기법은 플라이웨이트 패턴(Flyweight pattern)과 비슷한 기법이다.

또한 같은 클래스를 반환하기에 인스턴스 통제가 가능하다. (싱글톤, 인스턴스화 불가)

## 반환 타입의 하위 타입 객체를 반환할 수 있는 능력

객체의 유연성을 제공한다. 구현 클래스를 공개하지 않고 해당 객체를 반환할 수 있어 API 를 작게 유지할 수 있다. API 를 작게 유지한다는 것은 API 를 사용하는 프로그래머가 익혀야하는 단위가 줄어든다는 것을 의미한다.

본 장점의 대표적인 예로는 45개의 유틸리티 클래스를 공개하지 않은 `java.util.Collections` 이다.

## 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음

반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관이 없다.

`EnumSet` 은 정적 팩토리 메소드로 `RegularEnumSet` 과 `JumboEnumSet` 를 반환한다. 클라이언트는 메소드로 건네주는 두 클래스의 존재를 모르며 `EnumSet` 의 하위 클래스기만 하면 된다.

## 정적 팩토리 메소드를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않아도 됨

서비스 제공자 프레임워크의 근간이며, 본 장점의 대표적인 예로는 JDBC(Java Database Connectivity)이다.

서비스 제공자 프레임워크는 3가지(+1가지) 핵심 컴포넌트로 구성된다.

1. **서비스 인터페이스**: 구현체의 동작을 정의
   - **서비스 제공자 인터페이스**: **서비스 인터페이스**의 인스턴스를 생성하는 팩토리 객체를 설명하며 없다면 리플렉션을 통해 **서비스 인터페이스**를 만들어야한다.
2. **제공자 등록 API**: 제공자가 구현체를 등록하기 위해 사용
3. **서비스 접근 API**: 클라이언트가 서비스의 인스턴스를 얻을 떄 사용

> 클라이언트 > 원하는 구현체의 조건 제시 > 서비스 접근 API

원하는 구현체의 조건 제시를 확인하여 **유연한 정적 팩토리**를 구성하게 된다.

해당 내용을 JDBC 의 구현체로 나열한다면 다음과 같다.

1. **서비스 인터페이스**: `Connection`
   - **서비스 제공자 인터페이스**: `Driver`
2. **제공자 등록 API**: `DriverManager.registerDriver`
3. **서비스 접근 API**: `DriverManager.getConnection`

서비스 제공자 프레임워크는 여러가지 변형이 있으며 스프링의 자주 언급되는 의존성 주입(Dependency Injection)도 이에 속한다.

### 상속을 하려면 `public` 이나 `protected` 생성자를 필요로 하여 정적 팩토리 메소드만 제공시 하위 클래스를 만들수 없음

앞서 `Collections` 의 유틸리티 클래스를 상속할수 없다는 이야기이다.

본 단점은 상속이 아닌 조합(컴포지션)으로 사용하도록 유도하고 불변 타입을 유도한다는 제약을 지키는 것으로 장점으로 승화될 수 있다.

> ✏ Note: 정적 팩토리 메소드로 제공시 상속을 사용하는 것을 지양해야 할까?

## 정적 팩토리 메소드는 프로그래머가 찾기 어려움

생성자처럼 API 설명으로 드러나지 않아 프로그래머가 인스턴스화 하는 방법을 알아내야 한다. 메소드 명이나 자바독으로 단점을 해소해야 한다.

- `from` : 매개변수를 하나 받아 해당 타입의 인스턴스를 반환하는 *형변환 메소드*
- `of` : 매개변수를 여러개 받아 적합한 타입의 인스턴스를 반환하는 *집계 메소드*
- `valueOf` : `from` 과 `of` 의 자세한 버전
- `instance` 또는 `getInstance` : 매개변수로 명시한 인스턴스를 반환하되, **같은 인스턴스임을 보장하지 않음**
- `create` 또는 `newInstace` : `instance` 또는 `getInstance` 과 같지만, **항상 새로운 인스턴스를 반환함을 보장함**
- `getType` : 생성할 클래스가 아닌 다른 클래스에 팩토리 메소드를 정의할때 사용한다. *Type* 은 팩토리 메소드가 반환할 객체의 타입이 된다.
- `newType` : `getType` 과 같지만, **항상 새로운 인스턴스를 반환함을 보장함**
- `type` : `getType` 과 `newType` 의 간결한 버전
