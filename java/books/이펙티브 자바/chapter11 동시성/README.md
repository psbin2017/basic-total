# 💎 11장: 동시성

> 스레드는 여러 활동을 동시에 수행할 수 있게 해준다.

그러나 동시성 프로그래밍(멀티스레드 프로그래밍)은 단일 스레드 프로그래밍보다 어렵다.

1. 잘못될 수 있는 일이 늘어난다.
2. 문제를 재현하기도 어렵다.

그러나 **언제까지나 도망다닐 수 없다.** 멀티 코어 프로세서의 힘을 제대로 활용하려면 반드시 내 것으로 만들어야 하는 기술이다.

- - -

## Intro

> **사실 해당 챕터는 요약이 거의 불가능함**. 가능하면 각 아이템 별로 회귀하여 읽는 것이 바람직해보임.

## 동기화

> 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.

1. 응답 불가와 안전 실패를 피하려면 동기화 메소드나 동기화 블록 안에서 제어를 **절대로 클라이언트에 양도하면 안된다.**

### 배타적 실행

> 동기화는 일관성이 깨진 상태를 볼 수 없으며, 동기화된 메소드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.

1. (A Thread) → [(B Method/Block)] → [(B Method/Block A Thread changed)]
2. (C Thread) → **[(B Method/Block A Thread changed)]** → ...

### 통신

스레드가 필드를 읽을 때 **항상 '수정이 완전히 반영된' 값을 얻는다고 보장**하지만, 한 스레드가 **저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다.**

### 서비스 거부 공격

공개된 락을 오래 쥐고 놓지 않는 방식을 서비스 거부 공격(denial-of-service attack)이라 한다.

이를 막으려면 `synchronized` 에서 사용하는 `lock` 객체를 클라이언트 바깥에서 볼 수 없는 객체여야 한다. 또한 `final` 로 선언하여 락 필드 객체의 변경 가능성을 최소화하라.

## 가변 데이터 공유

> 여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.

- 가변 데이터는 단일 스레드에서만 쓰도록 노력하자. (정책상 정해졌다면, 문서화하자)
- 읽고 쓰는 메소드를 `synchronized` 사용하는게 가장 쉬운 방법.
- `volatile` 한정자를 사용하는 방법도 있지만, 잘못 사용시 안전 실패를 유발한다.
- `java.util.concurrent.atomic` 패키지 사용하자.

### 가변 클래스 작성

- 동기화를 전혀 하지 말고, 해당 클래스를 동시에 사용해야 하는 클래스가 외부에서 얼아서 동기화 하게 하자.
- 동기화를 내부에서 수행하여 스레드 안전한 클래스로 만들자.
  - 단, 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등하게 개선할수 있는 경우만.

## 실행자, 태스크, 스트림

> 손수 작업 큐를 만드는 경우는 삼가야 하고, 스레드를 직접 다루는 것도 일반적으로 삼가야 한다.

이를 위해 실행자 프레임워크를 제공한다. 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.

- 작업 단위: 태스크
  - Runnable : 실행만 한다.
  - Callable : 값을 반환하고 예외를 던질수 있다.

- 태스크를 수행하는 실행 메커니즘 : 실행자 서비스

추가로 포크-조인 태스크와 이를 사용한 병렬 스트림을 활용하자.

## 레거시 코드 작성시 주의사항

> 레거시 코드라면 `wait` 는 반드시 대기 반복문 관용구로 작성하고, `notify` 보다는 `notifyAll` 을 사용하자.

## 문서화

동기화 수준이 어느정도인지 그리고 그에 대한 해결 방법이나 작성 방법은 무엇인지 문서화해야한다.

## 지연 초기화

필요하지 않은 경우라면 일반 초기화를 할 것. 필요하다면 홀더 관용구나 이중 검사 관용구 등으로 작성할 것.

## 스케줄러

가장 좋은 방법은 적절한 스레드 수를 설정한다. (코어와 프로세스 수와 같은)

작업은 짧게 유지한다.
