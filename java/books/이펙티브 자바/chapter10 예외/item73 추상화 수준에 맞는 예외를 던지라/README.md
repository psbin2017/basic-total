# ✨ 아이템 73: 추상화 수준에 맞는 예외를 던지라

메소드가 저수준 예외를 처리하지 않고 바깥으로 전파해버리면 수행하려는 일과 관련 없어 보이는 예외를 튀어나오게 한다. 이는 단순히 놀래키는 것 뿐만 아니라 내부 구현 방식을 드러내어 윗 레벨 API 를 오염시킨다.

다음 릴리스에서 구현 방식을 바꾸면 다른 예외가 튀어나와 기존 클라이언트 프로그램을 깨지게 할 수도 있다.

> 이 문제를 피하려면 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꾸어 던져야 한다.

이를 예외 번역이라고 한다.

```java
try {
    // 저수준 추상화를 이용한다.
} catch (LowerLevelException e) {
    // 추상화 수준에 맞게 번역한다.
    throw new HigherLevelException(...);
}
```

예외 연쇄는 상위 클래스의 생성자에게 '원인'을 건네주어, 최종적으로 Throwable(Throwable) 생성자까지 건네지게 한다.

```java
try {
    // 저수준 추상화를 이용한다.
} catch (LowerLevelException cause) {
    // 추상화 수준에 맞게 번역한다.
    throw new HigherLevelException(cause);
}

class HigherLevelException extends Exception {
    HigherLevelException(Throwable cause) {
        super(cause);
    }
}
```

대부분의 표준 예외는 예외 연쇄용 생성자를 가지고 있다. 그렇지 않은 예외라 할지라도 Throwable 의 `initCause` 메소드를 사용하여 원인을 직접 못박을 수 있다.

**무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이겠지만, 그렇다고 남용하면 곤란하다.** 최선은 저수준의 메소드가 반드시 성공하도록 보장하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이다. 때론 **상위 계층 메소드의 매개변수 값을 아래 계층 메소드로 건네기 전에 미리 검사하는 방법**으로 이 목적을 달성할 수 있다.

차선책은 예외를 피할 수 없다면 상위 계층에서 예외를 조용히 처리하는 것이다. 이 경우 적절한 로깅을 활용하여 기록하는 것이 좋다. 문제를 전파하지 않으면서 로그를 분석하여 추가 조치를 취할 수 있게 해준다.
