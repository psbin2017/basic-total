# 💎 7장: 람다와 스트림

자바 8에 추가된 함수형 인터페이스, 람다, 메소드 참조로 함수 객체를 쉽게 만들 수 있게 되었다. (함수형 프로그래밍) 추가로 스트림 API 도 지원하게 되었다.

본 장에서는 이 기능을 효과적으로 사용하는 방법을 학습한다.

## ✨ 아이템 45: 스트림은 주의해서 사용하라

스트림은 다량의 순차/병렬 데이터 처리 작업을 돕고자 자바8 에서 추가되었다. 스트림의 추상 개념의 핵심은 2가지다.

- 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻한다
- 스트림 파이프 라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.

스트림의 원소들은 어디로부터든 올 수 있다. (컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수 생성 그리고 다른 스트림) 스트림의 원소들은 객체 참조나 기본 타입 값이다. 기본 값은 int, long double 을 지원한다.

```java
// char 스트림은 없다. int 결과가 나온다.
"Hello World".chars().forEach(System.out::print);

// 스트림을 안쓰는게 낫다.
"Hello World".chars().forEach(x -> System.out.print((char) x));
```

### 스트림 파이프라인

> 스트림.중간연산.종단연산

중간 연산은 열린 스트림에 대한 가공되거나 동일한 스트림을 제공한다. (특정 조건에 대한 필터링)

종단 연산은 스트림에 대한 최후의 연산을 수행한다. (원소를 컬렉션에 담거나, 특정 원소를 고르거나, 모든 원소를 출력하는 등)

파이프라인은 지연 평가(lazy evaluation)된다. 평가는 종단 연산이 호출되는 시점에 이루어지고 종단 연산에 쓰이지 않는 데이터는 계산에 쓰이지 않는다. 종단 연산이 없는 스트림 파이프라인은 아무일도 하지 않는 존재가 되니 종단 연산을 빼먹지 않도록하자.

스트림은 메소드 체이닝을 지원하는 플루언트 API 이다. 하나의 파이프라인을 구성할 수도 있고 여러 개의 파이프라인을 연결할 수도 있다.

기본적으로 스트림 파이프라인은 순차적으로 수행하는데 병렬로 실행하고자하면 parallel 메서드를 호출해주기만 하면 되나, 효과를 볼 수 있는 상황은 많지 않다.

### 스트림의 숙제

스트림을 과용하면 프로그램이 읽거나 유지보수하기가 어려워지는 단점이 있다. 특히 중간 연산이 많거나 복잡한 연산이 이에 해당한다. 연산에서 람다를 사용하게 되는데 이때 매개변수 명을 주의해서 정해야 한다. 람다에서는 타입 이름을 자주 생략하므로 매개변수 이름을 잘지어야 파이프라인의 가독성이 유지된다.

주 구현에서 세부 구현을 로직 밖으로 빼는 과정으로 가독성을 개선할 수도 있을 것이다.

스트림을 쓰기 시작하면 모든 반복문을 스트림으로 바꾸고 싶은 욕망이 생긴다. 하지만 앞서 언급한 가독성과 유지보수에서 오히려 손해를 가져올 수 있다. 이보단 상황에 따라 적절하게 반복문과 스트림을 조합하는게 좋다. 따라서 **기존 코드에서 스트림을 사용해서 리팩토링 해보고 좋으면 반영하자.**

코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 그러나 람다는 final 이거나 사실상 final 인 변수를 읽을 수 있고, 지역변수를 수정하는 건 불가능하다. (effectively final)

코드 블록에서는 return 을 사용해 메소드에 빠져나가거나 break 나 continue 문으로 블록 바깥의 반복문을 종료하거나 반복을 한 번에 건너뛸 수 있다. 또한 메소드 선언에 명시된 검사 예외를 던질 수 있다. 그러나 람다는 불가능하다.

#### effectively final

[LambdaEffectivelyFinal](https://github.com/psbin2017/garbage-collection/blob/master/gc/src/test/java/com/collection/gc/sample/lambda/LambdaEffectivelyFinal.java)

> Variable used in lambda expression should be final or effectively final (람다 식에 사용되는 변수는 final 또는 사실상 final 이어야합니다.)

람다 연산 내부에서 지역 변수 사용시 에러가 발생한다. final 로 선언되지 않은 값임에도 발생하는데 오류에서 서술되었듯이 final 이 아님에도 final 속성을 가져야 한다는 뜻이다. 즉, 지역변수의 재할당이 이루어져서는 안된다는 것을 말한다.

- 람다는 지역 변수가 위치하는 스택 영역에 직접 접근하지 않고 지역 변수를 자신이 사용하는 스레드의 스택에 복사한다. (람다 캡쳐링)

- 멀티스레드에서 람다를 사용한다면 외부로 참조하는 값이 변할 수 있기 때문에 동기화 문제가 발생한다. 따라서 final 속성을 가져야 한다.

그러나 힙 메모리 영역에 할당되는 인스턴스 변수와 정적 변수는 모든 스레드가 공유 가능한 메모리에 할당 되기 때문에 final 속성을 가질 필요가 없다.

### 스트림 선택 결정

- 원소들의 시퀀스를 일관되게 변환한다.
- 원소들의 시퀀스를 필터링한다.
- 원소들의 시퀀스를 하나의 연산을 사용해 결합한다. (더하기, 빼기, 연결하기, 최솟값 등)
- 원소들의 시퀀스를 컬렉션으로 모은다. (기준을 만들어)
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

### 스트림의 숙제2

스트림이 처리하기 어려운 일이 있는데 스트림은 파이프라인 과정에서 가졌던 값에 대해 원래의 값을 잃는 구조이다. (우회할 수도 있지만 좋은 방법은 아니다.) 기존 값을 사용하는 단계가 많을 수록 특히 더 그렇다. 이러면 코드도 지저분해지고 스트림의 목적에 벗어나게 된다.

// ... 중복으로 부분 생략

따라서 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 적용해보고 더 나은쪽을 택하도록 하자.