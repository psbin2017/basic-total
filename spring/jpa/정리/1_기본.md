# 기본

## 영속성 컨텍스트

> 엔티티를 영구 저장하는 환경으로 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트를 관리한다.

- 영속성 컨텍스트와 식별자 값: 영속 상태는 식별자 값이 반드시 있어야 한다. (`@Id` 로 테이블의 기본 키와 매핑한 값)
- 영속성 컨텍스트와 데이터베이스 저장: 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 저장된 엔티티를 데이터베이스를 반영한다. 이를 플러시(Flush)라 한다.

1. 1차 캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기 지원
4. 변경 감지 (Dirty Checking)
5. 지연 로딩 (Lazy Loading)

### 라이프 사이클

- 비영속(new/transient) : 영속성 컨텍스트와 **전혀 관계**가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 **저장**된 상태 (`em.find()`)
- 준영속(detached) : 영속성 컨텍스트에 **저장되었다가 분리된** 상태 (`em.detach()`)
  - 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 **불가능** ... 영속성 컨텍스트 관리 대상이 아님
  - 식별자를 가지고 있다.
  - 준영속 상태의 엔티티를 병합을 통해 새로운 영속 상태의 엔티티를 반환 받을 수 있다.
- 삭제(deleted) : **삭제**된 상태 (`em.remove()`)

![entity life cycle](../../../java/books/자바%20ORM%20표준%20프로그래밍/images/entity-lifcycle.png)

### 엔티티 매니저 팩토리와 엔티티 매니저

| 객체 | 비용 | 스레드 |
| --- | --- | --- |
| `EntityManagerFactory` | 객체 생성에 비용이 많이 들어간다. | 여러 스레드가 접근해도 안전하다. |
| `EntityManager` | 팩토리에서 생성하며 비용이 거의 들지 않는다. | 스레드간 공유시 동시성 문제가 발생하여 공유하면 안된다. |

### 플러시

> 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것을 말한다.

플러시 방법은 3가지가 있다.

1. 직접호출
2. 트랜잭션 커밋시 플러시 자동 호출
3. JPQL 쿼리 실행시 플러시 자동 호출

- `FlushModeType.AUTO` : 커밋이나 쿼리를 실행할 때 플러시(기본값)
- `FlushModeType.COMMIT` : 커밋할 때만 플러시 (성능 최적화)

### 지연 로딩 `@XtoOne(fetch = FetchType.LAZY)`

> 엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 조회하는 방법

### 프록시

> 지연 로딩 기능을 사용하면서 실제 엔티티 객체 대신 데이터베이스 조회를 지연할 수 있는 가짜 객체

#### 프록시 객체의 초기화

1. 실제 엔티티 객체 요청
2. 영속성 컨텍스트에 실제 엔티티가 없다면 영속성 컨텍스트에 엔티티 생성을 요청 (**프록시 초기화**)
3. 영속성 컨텍스트가 데이터베이스를 조회하여 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버변수에 보관한다.
5. 프록시 객체는 실제 엔티티 객체의 `getName()` 을 호출하여 결과를 반환한다.

엔티티 접근 방식을 따로 설정하지 않았다면(`@Access(AccessType.FIELD)`), 식별자를 호출해도 **프록시를 초기화하지 않는다.**

## 조인 전략

- `@JoinColumn(nullable = true)` : NULL 허용(기본값), 외부 조인 사용 (LEFT OUTER JOIN)
- `@JoinColumn(nullable = false)` : NULL 비허용, 내부 조인 사용 (INNER JOIN)

혹은 다음 처럼 `@ManyToOne(optional = false)` 로 설정해도 내부 조인을 사용한다.

## 영속성 전이

> 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶다면 영속성 전이 기능을 사용한다.

**JPA 에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.** 연관관계를 매핑하는 것과는 관계가 없다. 단지 **엔티티를 영속화할 때 연관 엔티티도 같이 영속화하는 편리함을 제공하는 것이다.**

```java
public enum CascadeType {
    ALL, // 모두 적용
    PERSIST, // 영속
    MERGE, // 병합
    REMOVE, // 삭제
    REFRESH, // REFRESH
    DETACH // DETACH
}
```

`CascadeType.PERSIST`, 와 `CascadeType.REMOVE` 는 `em.persist()`, `em.remove()` 실행 시 전이가 바로 발생하지 않고 **플러시 호출**시 전이가 발생한다.

## 고아 객체

> 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능

**부모 엔티티의 컬렉션에서 자식 엔티티 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.**

부가적으로 고아 객체 제거에는 부모가 제거되면 자식도 같이 제거된다.

## 영속성 전이 + 고아 객체, 생명주기

> `CascadeType.ALL` + `orphanRemoval = true` 동시 사용시 부모 엔티티를 통해서 자식 엔티티의 생명주기를 관리할 수 있다.

## 타입

- 기본 값 타입 (basic value type)
  - 자바 기본 타입 (`int`, `double`)
  - 래퍼 클래스 (`Integer`)
  - String
- 임베디드 타입 (embedded type) ... 복합 값 타입
  - `@Embedded`: 값 타입을 정의하는 곳에서 표시
  - `@Embeddable`: 값 타입을 사용하는 곳에서 표시
- 컬렉션 타입 (collection value type)

- 엔티티 타입의 특징
  - 식별자가 있다. (`@Id`)
  - 생명주기가 있다. 생성하고, 영속화되고, 소멸되는 주기가 있다.
    - `em.persis(entity)`
    - `em.remove(entity)`
  - 공유할 수 있다. 회원 엔티티가 있다면 다른 엔티티에서 언제든지 회원 엔티티를 참조할 수 있다. (엔티티와 연관관계를 가질 수 있다.)

- 값 타입의 특징
  - 식별자가 없다.
  - 엔티티가 생명주기를 관리한다.
  - 공유하지 않는 것이 안전하다.
    - 공유해야 한다면 객체를 복사해야한다.
    - 하나의 주인만이 관리해야 한다.
    - 불변 객체로 만드는 것이 안전하다. (이건 엔티티도 포함)
