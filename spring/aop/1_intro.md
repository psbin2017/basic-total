# AOP 요약

이전 gitbook legacy AOP 작성 부분에서 짜집기하여 작성한다.

## 필요성

객체 지향 프로그래밍(OOP)가 공통된 기능을 재사용하는 것에 대한 방법은 이미 존재한다. (상속과 위임) 그러나 전체 애플리케이션에 여기저기에 사용되는 부가기능을 상속이나 위임으로 처리하기에는 모듈의 분리가 어렵다.

이에 요구에 따라 관점 지향 프로그래밍(AOP)은 부가기능 자체를 모듈화하여 관리하고, 서비스는 부가기능을 최대한 신경쓰지 않아도 된다. 이러한 부가기능은 애플리케이션 전체에 적용될 수도 있는데, 이를 인프라 로직이라고 말할 수 있다.

- OOP 의 모듈 단위는 서비스를 수행하는 비지니스 로직, 종단에 대한 기능
- AOP 의 모듈 단위는 서비스에 대한 부가기능, 횡단에 대한 기능

*****

## 용어

### `Aspect`

핵심 기능에 대한 부가기능을 가진 모듈 (작성한 모듈 그 자체)

### `Target`

부가 기능을 사용할 대상을 말한다.

### `Advice`

> "무엇", "언제"

실제 동작을 가지는 부가기능 코드를 말한다. 더하여 어드바이스는 대상이 되는 코드의 실행 시점을 가진다.

### `PointCut`

> "누가"

어드바이스에 대상이 되는 적용 대상을 결정하는 표현식이다.

### `JoinPoint`

> "어디에서"

실행 가능한 특정 지점을 정한다. 단 스프링은 **메소드** 조인포인트만 제공한다.

### `Proxy`

> 프록시("누가")

대상이 되는 타겟을 감싸 요청을 대신 받는 래핑 객체이다.

### `Introduction`

대상이 되는 타겟 객체의 코드 변경 없이 메소드, 변수 등을 추가하는 기능이다.

### `Weaving`

대상이 되는 타겟 객체를 프록시 객체로 생성하는 과정이다.

*****

## 구분

| | Spring AOP | AspectJ |
| --- | --- | --- |
| 제공 범위 | 간단한 AOP | 모든 AOP |
| `JoinPoint` | 메소드 레벨 | 생성자, 필드, 메소드 등의 다양한 레벨 |
| `Weaving` | 런타임 | 런타임을 제외한 컴파일 시점, 컴파일 이전 시점, 로드 타임 시점 |
| 적용 가능 대상 | IoC 컨테이너가 관리하는 빈 | 모든 자바 객체 |

### 컴파일 기반 (Aspect J)

> A.java → (AOP) → A.class

`A.java` 파일이 컴파일 되는 시점에 AOP 코드를 끼워 넣어 `A.class` 가 된다.

### 바이트코드 조작 (Aspect J)

> A.java → A.class → in memory (AOP) A.class (런타임에서 클래스 로더)

`A.java` 파일을 `A.class` 파일로 컴파일하고 난후 런타임에서 클래스 로더가 메모리로 올리는 시점에 바이트 코드를 조작하여 `A.class` 에 AOP 코드를 끼워 넣는다.

### 프록시 패턴 기반 (Spring AOP)

> 디자인 패턴 기반의 AOP

AOP 를 적용하지 않은 AService 의 `.getClass().getName()` 실행시 `패키지.AService` 로 찍힐 것이다.

그러나 AOP 를 적용한 AService 의 `.getClass().getName()` 실행시 `패키지.AService$$~~~` 로 찍힌다. 이를 열어보게 되면 프록시 객체가 AService 를 감싸서 담고 있는 것을 확인할 수 있다.

*****

## 어드바이스

### `@Before`

```text
[request] → [advice] → [target]
```

### `@AfterReturning`

```text
[request] → [target (정상 반환)] → [advice]
```

### `@AfterThrowing`

```text
[request] → [target (예외 발생)] → [advice]
```

### `@After`

```text
[request] → [target] → [advice]
```

### `@Around`

```text
[request] → [advice] → [target] → [advice]
```

### 어드바이스의 실행 순서

여러 개의 어드바이스가 모두 같은 조인포인트에서 실행될 때 어떤 일이 발생하는가? 스프링 AOP 는 AspectJ 와 동일한 선행 규칙을 따라 어드바이스 실행 순서를 결정한다.

- "안으로 들어갈 때(`@Before`)" 는 우선 순위가 가장 높은 어드바이스가 먼저 실행된다. 이에 따라 비포가 2개가 주어진다면 가장 우선 순위가 높은 비포가 먼저 실행된다.
- "밖으로 나올 때(`@After` ~~)" 는 가장 높은 우선 순위 어드바이스가 마지막으로 실행된다. 따라서 2개의 애프터가 주어지면 우선 순위가 가장 높은 애프터가 2번째 실행된다.

`Order` 어노테이션으로 일반적인 스프링 방식으로 수행된다. 2가지 애스팩트에서 보면 `Ordered.getValue()` (또는 어노테이션 값) 에서 낮은 값을 반환하는 애스펙트가 더 높은 우선 순위를 가진다.

> 여러 개의 어드바이스에 대상이 된다는 것은 리팩토링 해야하는 상황일 수 도 있다는 것을 인지해야 한다.

*****

## 포인트 컷

포인트 컷은 크게 지정자와 타겟 명세로 나누어진다. 지정자는 다음과 같다.

### `execution`

메소드 실행 조인포인트를 매치시키기 위해, 이것은 스프링 AOP 로 작업 할 때 사용할 기본 포인트컷 지정자이다.

### `within`

특정 타입내에서 조인포인트와 일치하는 한계. (조인포인트: 스프링 AOP 를 사용할 때 단순히 일치하는 타입내에서 선언 된 메소드의 실행)

### `this`

빈 참조가 주어진 타입의 인스턴스인 조인포인트와 일치하는 한계. (빈 참조: 스프링 AOP proxy) (조인포인트: 스프링 AOP를 사용할 때 메소드의 실행)

### `target`

조인포인트에 일치하는 한계 대상 객체가 주어진 타입의 인스턴스인 경우. (조인포인트: 스프링 AOP 를 사용할 때 메소드 실행) (대상 객체: 프록시될 애플리케이션 객체)

### `args`

조인포인트에 일치하는 제한. (조인포인트: 스프링 AOP 을 사용할 때 메소드 실행) 인수는 주어진 타입의 인스턴스이다.

### `@target`

실행 객체의 클래스가 주어진 타입의 어노테이션을 가지고 있는 조인포인트 와 일치하는 한계. (조인포인트: 스프링 AOP 를 사용할 때 메소드의 실행)

### `@args`

실제 인수의 런타임 타입이 주어진 타입의 어노테이션을 가지고있는 조인포인트와 일치하는 한계. (조인포인트: 스프링 AOP를 사용할 때 메소드의 실행)

### `@within`

주어진 어노테이션내에서 조인포인트와 일치하는 한계. (스프링 AOP 을 사용할 때 주어진 어노테이션으로 타입에서 선언된 메소드의 실행)

### `@annotation`

조인포인트의 주체가 주어진 어노테이션을 갖는 조인 포인트와 일치하는 한계. (스프링 AOP 에서 실행되는 메소드)

> ## Note
>
> 스프링의 AOP 의 프록시 기반 특성으로 인해 protected 메소드는 정의에 의해 차단되지 않으며 JDK 프록시 (적용할 수 없는 경우) 나 CGLIB 프록시 (기술적으로는 가능하지만 AOP 용도로는 권장되지 않음) 에는 사용할 수 없다. 결과적으로 주어진 포인트컷 은 public 메소드와만 일치한다!
>
> 인터셉터에 protected / private 메소드 또는 생성자가 필요한 경우 스프링의 프록시 기반 AOP 가 아닌 스프링 기반 네이티브 AspectJ 위빙의 사용을 고려하라. 이것은 다양한 특성을 가진 AOP 사용의 다른 모드를 구성하기 때문에 결정하기 전에 먼저 위빙에 익숙해져야한다.

*****

## 학습 내용 참고 출처

- [Spring document](https://docs.spring.io/autorepo/docs/spring-framework/5.0.0.M1/spring-framework-reference/pdf/spring-framework-reference.pdf)
- [[10분 테코톡] 🌕제이의 Spring AOP](https://www.youtube.com/watch?v=Hm0w_9ngDpM)
