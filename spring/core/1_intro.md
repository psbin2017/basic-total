# 제어의 역전

*객체의 생성*과 *객체간의 의존 관계*를 컨테이너에게 일임하여 **객체간의 결합도를 낮추는 것**이 제어의 역전(`IoC: Inversion of Control`)의 핵심 개념이다.

> 마틴 파울러는 `IoC` 의 명칭을 의존성 주입(`DI : Dependency Injection`)으로 제안하였다. 즉 두 단어는 동일한 개념을 가진 동의어이다.

## 의존 관계

객체간에 발생하는 의존 관계란 객체는 다른 객체와의 상호 작용을 하는데 이 관계를 의존 관계라고 한다.

## 컨테이너

> 객체의 생성과 객체간의 의존 관계를 해결하는 역할을 담당한다.

컨테이너의 역할을 자바로 자세히 풀어쓴다면 다음과 같다.

1. 객체를 인스턴스화한다.
2. 객체들을 조합한다.
    - 객체의 설정과 조합은 메타데이터를 통해 알아낸다.

`ApplicationContext` 인터페이스는 `IoC` 컨테이너를 말하며 `ApplicationContext` 가 생성되어 인스턴스화되면 설정이 완료되고 실행가능한 애플리케이션이 준비됨을 의미한다.

### 컨테이너의 의존성 처리

1. `ApplicationContext` 는 빈에 대한 정보를 담고 있는 메타데이터로 생성되고 초기화된다.
2. 정적 팩토리 메소드로 각 빈의 의존성을 나타낸다.
3. 빈이 실제로 생성되는 시점에 이러한 의존성을 빈에 주입한다.

프로퍼티나 생성자 인수 그리고 기본 생성자는 설정하려는 값에 대한 실제 정의이거나 컨테이너의 다른 빈에 대한 참조이다. 그리고 명시된 타입에서 해당 실제 타입으로 변환된다.

## 메타데이터

> 컨테이너가 객체를 생성할 때 필요한 정보를 말한다.

메타데이터를 작성하는 방법은 다음과 같다.

1. XML: 전통적인 방법
2. @Annontation: 스프링 2.5 부터 지원한 방법
3. 자바 기반: 스프링 3.0 부터 지원한 방법

## 빈

> 컨테이너가 생성하여 관리하는 객체를 말한다.

빈의 정의란 컨테이너가 필요로 하는 하나 이상의 **객체를 생성하기 위한 방법**을 말한다. 빈의 정의에는 다음의 메타데이터를 필요로 한다.

1. 패키지에 최적화된 클래스 명: 정의된 빈의 실제 구현 클래스
2. 빈의 행동에 대한 설정 요소들: 컨테이너에서의 빈의 동작 방법 (스코프, 라이프사이클, 콜백 등)
3. 빈이 동작하는데 필요한 다른 빈들에 대한 참조: 협력 객체 또는 의존성이라고 부른다.
4. 새로 생성된 객체에 설정해야 하는 그 외 설정 값: 커넥션 풀을 관리하는 빈에서 사용하는 커넥션 수 등과 같은 설정 값

```text
┌ IoC Container (ApplicationContext) ┐
│             <Meta Data>            │
│ [Bean] [Bean] [Bean] [Bean] [Bean] │
│ [Bean] [Bean] [Bean] [Bean] [Bean] │
│ [Bean] [Bean] [Bean] [Bean] [Bean] │
│ [Bean] [Bean] [Bean] [Bean] [Bean] │
└────────────────────────────────────┘
```

## 생성자 주입

> 컨테이너가 빈을 생성하기 위해 여러 개의 인수가 있는 생성자를 호출하는 방법이다.

특정 인수를 가진 정적 팩토리 메소드를 호출하는 것과 거의 동일하며 생성자와 정적 팩토리 메소드에 대한 인수를 유사하게 취급한다.

```java
public class SimpleMovieListener {

    // 명시적으로 불변으로 선언 할 수 있다.
    private final MovieFinder movieFinder;

    public SimpleMovieListener(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

## 세터 주입

> 컨테이너가 빈을 생성하기 위해 기본 생성자 또는 인수가 없는 정적 팩토리 메소드를 호출한 후 빈에서 세터 메소드를 호출하는 방법이다.

```java
public class SimpleMovieListener {

    private MovieFinder movieFinder;

    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

## 필드 주입

> 컨테이너가 빈을 생성하기 위해 기본 생성자 또는 인수가 없는 정적 팩토리 메소드를 호출한 후 어노테이션이 있는 빈을 호출하는 방법이다.

```java
public class SimpleMovieListener {
    @Autowired
    private MovieFinder movieFinder;
}
```

## 각 주입 순서 비교

`A Bean` 의 의존성 주입 과정 예시이다. `A Bean` 은 `B Bean` 에 의존성을 가진다. 풀어서 말하자면 `A Bean` 을 인스턴스화 하기 위해선 `B Bean` 이 필요하다.

세터 주입(Setter Injection)

1. `A Bean` 의 의존성인 `B Bean` 의 생성자를 호출한다. **(이 시점에 `B Bean` 은 생성된다)**
   - `B Bean` 이 생성(인스턴스화) 되지 않은 경우 빈 팩토리를 통해 생성한다.
2. `A Bean` 에서 `B Bean` 수정자를 호출하여 주입한다.

필드 주입(Field Injection)

1. 세터 주입 1. 과 동일 **(마찬가지로 이 시점에 `B Bean` 은 생성된다)**
2. `A Bean` 에서 어노테이션이 있는 `B Bean` 을 찾아 의존성을 주입한다.

생성자 주입(Constructor Injection)

1. `A Bean` 의 생성자를 호출한다.
2. `A Bean` 의 생성자에서 `B Bean` 의 생성자를 호출한다.
    - `B Bean` 이 인스턴스화 되지 않은 경우 빈 팩토리를 통해 인스턴스화 한다.

> `A Bean` 이 생성자로 생성되는 시점에 필요한 `B Bean` 을 주입한다.

## 의존성 해결 프로세스

컨테이너는 생성될 때 빈의 참조 프로퍼티가 유효한 빈을 참조하는지 등과 같은 각 빈의 설정에 대한 유효성을 확인한다. 그러나 빈 프로퍼티 자체는 **빈이 실제로 생성될 때까지 설정되지 않는다.** 컨테이너가 생성되면서 생성되는 빈은 미리 초기값으로 설정되어있는 **싱글톤 스코프**인 빈만 해당한다. 스코프가 정의되지 않았다면 빈은 요청된 경우에만 생성된다.

## 순환 의존성

`A Bean` 은 `B Bean` 에 의존성을 가지며, 반대로 `B Bean` 은 `A Bean` 에 의존성을 가진다.

세터 주입(Setter Injection)

1. `A Bean` 의 의존성인 `B Bean` 의 생성자를 호출한다.
2. `B Bean` 의 의존성인 `A Bean` 의 생성자를 호출한다.
3. 각 Bean 에서 수정자를 호출하여 주입한다.

필드 주입(Field Injection)

1. 세터 주입 1. 2. 와 동일
2. 각 Bean 에서 어노테이션이 붙은 Bean 을 찾아 의존성을 주입한다.

생성자 주입(Constructor Injection)

1. `A Bean` 의 생성자를 호출한다.
2. `A Bean` 의 생성자에서 `B Bean` 의 생성자를 호출한다.
3. `B Bean` 에서 `A Bean` 의 생성자를 호출한다.

> 생성자 주입시 컨테이너에서 이 순환 의존성을 감지하여 `BeanCurrentlyInCreationException` 을 발생 시킨다.

## 의존성 주입 결정 방법

1. 필수적 의존성은 생성자 주입
    - 서드 파티에 대한 레거시 클래스는 세터 메소드를 제공하지 않기 때문에 생성자 주입
    - 순환 의존성을 방지하기 위해서 생성자 주입
2. 선택적 의존성은 세터 주입
    - 단, `@Required` 를 통한 세터 주입에서 필수 의존성을 제안 가능

> `ApplicationContext` 는 생성자 주입으로 의존성이 주입되고 나서도 세터 주입을 지원한다.

## 의존성 해결

스프링 컨테이너는 설정 문제를 로딩하는 과정에서 찾아낸다. 빈이 **실제로 사용될 때 프로퍼티들을 설정하고 의존성을 해결**한다. 이는 객체나 객체의 의존성을 생성하는데 문제가 있다면 로드가 완료된 컨테이너가 예외를 생성할 수 있다.

`ApplicationContext` 가 기본적으로 미리 초기화된 싱글톤 빈으로 구현된 이유는 설정 이슈를 나중에 발견할 수 있는 가능성이 있기 때문이다. 빈이 실제로 사용되기 전 생성하기 위한 시간과 메모리에 대한 비용을 사용하면 설정 이슈를 나중에 발견하는 대신 `ApplicationContext` 를 생성할 때 발견할 수 있다.
